name: "C++ Extension Tests"

on:
  push:
    branches:
      - main
    paths:
      - 'torch_ttnn/cpp_extension/**'
      - 'tests/cpp_extension/**'
  pull_request:
    paths:
      - "torch_ttnn/cpp_extension/**"
      - "tests/cpp_extension/**"
  workflow_dispatch:
    inputs:
      docker_tag:
        description: "Docker container tag to use"
        required: false
        type: string
        default: "ghcr.io/tenstorrent/tt-metal/tt-metalium/ubuntu-22.04-ci-test-amd64:latest"

jobs:
  cpp-extension-tests:
    runs-on: ["in-service", "nfs"]
    container:
      image: ${{ github.event.inputs.docker_tag || 'ghcr.io/tenstorrent/tt-metal/tt-metalium/ubuntu-22.04-ci-test-amd64:latest' }}
      options: >-
        --rm -v /dev/hugepages-1G:/dev/hugepages-1G --device /dev/tenstorrent
        -v ${{ github.workspace }}:${{ github.workspace }} -w ${{ github.workspace }}
        -v /mnt/tt-metal-pytorch-cache/.cache:/root/.cache
    env:
      CACHE_DIR: /root/.cache/cpp-extension-cache
    defaults:
      run:
        shell: bash
    steps:
      - name: Install git-lfs for checkout
        run: |
          apt-get update -y
          apt-get install -y git-lfs
          git lfs install
      - uses: actions/checkout@v4
        with:
          lfs: true
          fetch-depth: 0
          submodules: "recursive"

      - name: Update system
        run: |
          apt update -y && apt upgrade -y
          apt install -y curl jq
      - name: Update .gitsubmodules
        run: |
          # Set pinned tt-metal ref here. Leave empty to auto-detect latest prerelease.
          # Should be set manually with each PR required to make it work with new tt-metal version
          TT_METAL_REF="v0.60.1"

          if [ -z "$TT_METAL_REF" ]; then
            # Auto-detect latest prerelease tag (e.g., v0.64.0-rc8)
            latest_pre_release=$(curl -s https://api.github.com/repos/tenstorrent/tt-metal/releases | jq -r '[.[] | select(.prerelease == true)][0].tag_name')
            RESOLVED_TT_METAL_REF="$latest_pre_release"
            echo "Auto-detected latest prerelease tag: $RESOLVED_TT_METAL_REF"
          else
            RESOLVED_TT_METAL_REF="$TT_METAL_REF"
            echo "Using pinned tt-metal ref: $RESOLVED_TT_METAL_REF"
          fi

          # Export for later steps
          echo "TT_METAL_REF=$RESOLVED_TT_METAL_REF" >> $GITHUB_ENV

      - name: Setup submodules
        run: |
          # Allow git operations in runner workspace paths
          git config --global --add safe.directory /__w/pytorch2.0_ttnn/pytorch2.0_ttnn || true
          git config --global --add safe.directory "${{ github.workspace }}" || true
          git config --global --add safe.directory "$(pwd)" || true

          # Retry helper with exponential backoff
          retry() {
            local max_attempts=${1:-5}; shift
            local attempt=1
            until "$@"; do
              if (( attempt >= max_attempts )); then
                echo "Command failed after ${attempt} attempts: $*"
                return 1
              fi
              echo "Command failed (attempt ${attempt}/${max_attempts}): $*"
              sleep $(( 2 ** attempt ))
              ((attempt++))
            done
          }

          # Be tolerant to network hiccups for submodule operations
          retry 5 git submodule sync --recursive
          retry 5 git submodule update --init --recursive

          # Check out the requested tt-metal ref inside the submodule without editing .gitmodules
          pushd torch_ttnn/cpp_extension/third-party/tt-metal
          # Avoid tag clobber issues if upstream moved tags; clean local tags and fetch with force
          git config fetch.prune true || true
          git config fetch.pruneTags true || true
          git tag -l | xargs -r -n 1 git tag -d || true
          retry 5 git -c protocol.version=2 fetch --all --tags --force --prune --prune-tags
          if echo "$TT_METAL_REF" | grep -q '^releases/'; then
            # Treat as branch on origin
            if git rev-parse --verify "$TT_METAL_REF" >/dev/null 2>&1; then
              retry 5 git checkout -f "$TT_METAL_REF"
            else
              retry 5 git checkout -B "$TT_METAL_REF" "origin/$TT_METAL_REF" || retry 5 git checkout -f "origin/$TT_METAL_REF"
            fi
          else
            # Treat as tag or plain ref
            retry 5 git -c advice.detachedHead=false checkout -f "tags/$TT_METAL_REF" || retry 5 git checkout -f "$TT_METAL_REF"
          fi
          # Update nested submodules to the versions recorded by the checked-out ref
          retry 5 git submodule sync --recursive
          retry 5 git submodule update --init --recursive
          # LFS for all nested submodules
          git submodule foreach --recursive 'git lfs fetch --all || true'
          git submodule foreach --recursive 'git lfs pull || true'
          popd

      - name: Install dependencies
        run: |
          apt upgrade -y && apt update -y
          apt install -y cmake python3 python3-venv python3-pip git-lfs ccache
          git config --global --add safe.directory /home/ubuntu/actions-runner/_work/pytorch2.0_ttnn/pytorch2.0_ttnn
          git config --global --add safe.directory /__w/pytorch2.0_ttnn/pytorch2.0_ttnn

          # Remove hugepages setup from install_dependencies.sh
          sed -i '/^configure_hugepages() {/,/^}/c\configure_hugepages() {\n    echo "Skip hugepages installation"\n}' ./torch_ttnn/cpp_extension/third-party/tt-metal/install_dependencies.sh
          ./torch_ttnn/cpp_extension/third-party/tt-metal/install_dependencies.sh

      - name: Install python dependencies
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip config set global.extra-index-url https://download.pytorch.org/whl/cpu
          # Tooling for testing/build; no project packages are installed here
          python3 -m pip install pytest-github-report

      - name: Install root package
        run: |
          # Upgrade pip to support editable installs with pyproject.toml
          python3 -m pip install --upgrade pip setuptools wheel
          # Installs top-level Python package 'torch-ttnn' (pure Python only).
          # This does NOT build the native C++ extension and does NOT install tt-metal's 'ttnn'.
          python3 -m pip install -e .[dev]

      - name: Build C++ Extension
        run: |
          export TT_METAL_HOME=$(realpath ./torch_ttnn/cpp_extension/third-party/tt-metal)
          # Determine tt-metal version for CMake
          TT_METAL_VERSION=""
          if [ -d "$TT_METAL_HOME/.git" ]; then
            TT_METAL_VERSION=$(cd "$TT_METAL_HOME" && git describe --abbrev=0 --tags 2>/dev/null | sed 's/^v//' || echo "")
          fi
          if [ -z "$TT_METAL_VERSION" ] && [ -n "${TT_METAL_REF:-}" ]; then
            TT_METAL_VERSION="${TT_METAL_REF#v}"
          fi
          if [ -z "$TT_METAL_VERSION" ]; then
            TT_METAL_VERSION="0.60.1"
            echo "Warning: Could not determine tt-metal version, using fallback: $TT_METAL_VERSION"
          else
            echo "Detected tt-metal version: $TT_METAL_VERSION"
          fi
          # Select clang-17 toolchain used by tt-metal to avoid default GCC-11
          TOOLCHAIN_PATH="cmake/x86_64-linux-clang-17-libstdcpp-toolchain.cmake"
          # Ensure CMake can locate Torch package config from current Python
          export CMAKE_PREFIX_PATH=$(python3 - <<'PY'
          import torch
          print(torch.utils.cmake_prefix_path)
          PY
          )
          # Forward toolchain and common flags to scikit-build-core/CMake
          # Pass VERSION_NUMERIC to tt-metal CMake to avoid fallback warnings
          export CMAKE_ARGS="-DCMAKE_TOOLCHAIN_FILE=${TT_METAL_HOME}/${TOOLCHAIN_PATH} -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER_LAUNCHER=ccache -DCMAKE_CXX_COMPILER_LAUNCHER=ccache -DWITH_PYTHON_BINDINGS=ON -DVERSION_NUMERIC=${TT_METAL_VERSION}"
          # Prefer clang-17 explicitly in case the toolchain file is not picked up early
          export CC=clang-17
          export CXX=clang++-17
          # Ensure tt-metal's Python package (ttnn) is built so _ttnncpp.so is present
          export LD_LIBRARY_PATH="${TT_METAL_HOME}/build/lib:${LD_LIBRARY_PATH:-}"
          # Ensure PEP517 backend & native build tools are available for pyproject builds
          python3 -m pip install --upgrade scikit-build-core cmake ninja
          # Builds and installs tt-metal's Python package 'ttnn' from the submodule root
          # (produces '_ttnncpp.so' and installs tt-metal shared libraries)
          # Guard against preinstalled PyPI wheels creating ABI/runtime mismatches
          python3 -m pip uninstall -y ttnn || true
          # Ensure we use the runner Python's cmake/ninja instead of any stale virtualenv in the submodule
          unset VIRTUAL_ENV || true
          USER_SCRIPTS_DIR=$(python3 -c 'import sysconfig; print(sysconfig.get_path("scripts"))')
          export PATH="${USER_SCRIPTS_DIR}:${PATH}"
          # Install from source (non-editable) to build and bundle native libs into the package
          python3 -m pip install --no-build-isolation "${TT_METAL_HOME}"

          # Compute installed ttnn build lib dir for runtime
          export TTNN_LIB_DIR=$(python3 -c 'import ttnn, pathlib; print(pathlib.Path(ttnn.__file__).parent.joinpath("build","lib"))')
          echo "TTNN_LIB_DIR=${TTNN_LIB_DIR}"

          # Early sanity check: ensure 'ttnn' and its pybind module resolve
          export LD_LIBRARY_PATH="${TTNN_LIB_DIR}:${LD_LIBRARY_PATH:-}"
          python3 -c "import importlib, os; print('TT_METAL_HOME=', os.environ.get('TT_METAL_HOME')); import ttnn; importlib.import_module('ttnn._ttnn'); print('import ttnn OK')"

          cd torch_ttnn/cpp_extension
          # Ensure pip is up to date for editable installs
          python3 -m pip install --upgrade pip setuptools wheel
          # Builds and installs our project C++ extension package 'torch_ttnn_cpp_extension'
          # using scikit-build-core/CMake, linking against tt-metal libraries
          python3 -m pip install -e .
          cd ${{ github.workspace }}

      - name: Run C++ Extension Tests
        env:
          TT_METAL_HOME: ${{ github.workspace }}/torch_ttnn/cpp_extension/third-party/tt-metal
        run: |
          export TT_METAL_HOME=$(realpath ./torch_ttnn/cpp_extension/third-party/tt-metal)
          # Test phase: imports 'ttnn' (from tt-metal) and our 'torch_ttnn_cpp_extension'.
          # Ensure runtime can locate shared libraries when importing ttnn/_ttnn
          export TTNN_LIB_DIR=$(python3 -c 'import ttnn, pathlib; print(pathlib.Path(ttnn.__file__).parent.joinpath("build","lib"))')
          # Set up LD_LIBRARY_PATH to include tt-metal build directories and ttnn lib directories
          export LD_LIBRARY_PATH="${TT_METAL_HOME}/build_Release/lib:${TT_METAL_HOME}/build/lib:${TTNN_LIB_DIR}:${LD_LIBRARY_PATH:-}"
          echo "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"

          echo "Running C++ extension tests"
          pytest tests/cpp_extension/test_cpp_extension_functionality.py -v

          echo "Running BERT C++ extension tests"
          pytest tests/cpp_extension/test_bert_cpp_extension.py -v

          # echo "Running models C++ extension tests"
          # pytest tests/models/ --native_integration -v

          echo "Running tests passed"

  tests-passed:
    if: ${{ always() }}
    outputs:
      didpass: ${{ steps.check.outputs.didpass }}
    runs-on: ubuntu-latest
    needs: [cpp-extension-tests]
    steps:
      - id: check
        run: |
          cpp_tests_result="${{ needs.cpp-extension-tests.result}}"
          if [[ $cpp_tests_result == "success" || $cpp_tests_result == "skipped" ]]; then
            echo "didpass=0" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "didpass=1" >> $GITHUB_OUTPUT
            exit 1
          fi
