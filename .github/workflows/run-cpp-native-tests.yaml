name: "C++ Extension Tests"

on:
  push:
    branches:
      - main
    paths:
      - 'torch_ttnn/cpp_extension/**'
      - 'tests/cpp_extension/**'
  pull_request:
    paths:
      - "torch_ttnn/cpp_extension/**"
      - "tests/cpp_extension/**"
  workflow_dispatch:
    inputs:
      docker_tag:
        description: "Docker container tag to use"
        required: false
        type: string
        default: "ghcr.io/tenstorrent/tt-metal/tt-metalium/ubuntu-22.04-ci-test-amd64:latest"

jobs:
  cpp-extension-tests:
    runs-on: ["in-service", "nfs"]
    container:
      image: ${{ github.event.inputs.docker_tag || 'ghcr.io/tenstorrent/tt-metal/tt-metalium/ubuntu-22.04-ci-test-amd64:latest' }}
      options: >-
        --rm -v /dev/hugepages-1G:/dev/hugepages-1G --device /dev/tenstorrent
        -v ${{ github.workspace }}:${{ github.workspace }} -w ${{ github.workspace }}
        -v /mnt/tt-metal-pytorch-cache/.cache:/root/.cache
    env:
      CACHE_DIR: /root/.cache/cpp-extension-cache
    defaults:
      run:
        shell: bash
    steps:
      - name: Install git-lfs for checkout
        run: |
          apt-get update -y
          apt-get install -y git-lfs
          git lfs install
      - uses: actions/checkout@v4
        with:
          lfs: true
          fetch-depth: 0
          submodules: "recursive"

      - name: Update system
        run: |
          apt update -y && apt upgrade -y
          apt install -y curl jq
      - name: Update .gitsubmodules
        run: |
          # Set pinned tt-metal ref here. Leave empty to auto-detect latest prerelease.
          # Should be set manually with each PR required to make it work with new tt-metal version
          TT_METAL_REF="releases/v0.60.1"

          if [ -z "$TT_METAL_REF" ]; then
            # Auto-detect latest prerelease tag (e.g., v0.64.0-rc8)
            latest_pre_release=$(curl -s https://api.github.com/repos/tenstorrent/tt-metal/releases | jq -r '[.[] | select(.prerelease == true)][0].tag_name')
            RESOLVED_TT_METAL_REF="$latest_pre_release"
            echo "Auto-detected latest prerelease tag: $RESOLVED_TT_METAL_REF"
          else
            RESOLVED_TT_METAL_REF="$TT_METAL_REF"
            echo "Using pinned tt-metal ref: $RESOLVED_TT_METAL_REF"
          fi

          # Export for later steps
          echo "TT_METAL_REF=$RESOLVED_TT_METAL_REF" >> $GITHUB_ENV

      - name: Setup submodules
        run: |
          # Allow git operations in runner workspace paths
          git config --global --add safe.directory /__w/pytorch2.0_ttnn/pytorch2.0_ttnn || true
          git config --global --add safe.directory "${{ github.workspace }}" || true
          git config --global --add safe.directory "$(pwd)" || true

          # Retry helper with exponential backoff
          retry() {
            local max_attempts=${1:-5}; shift
            local attempt=1
            until "$@"; do
              if (( attempt >= max_attempts )); then
                echo "Command failed after ${attempt} attempts: $*"
                return 1
              fi
              echo "Command failed (attempt ${attempt}/${max_attempts}): $*"
              sleep $(( 2 ** attempt ))
              ((attempt++))
            done
          }

          # Be tolerant to network hiccups for submodule operations
          retry 5 git submodule sync --recursive
          retry 5 git submodule update --init --recursive

          # Check out the requested tt-metal ref inside the submodule without editing .gitmodules
          pushd torch_ttnn/cpp_extension/third-party/tt-metal
          # Avoid tag clobber issues if upstream moved tags; clean local tags and fetch with force
          git config fetch.prune true || true
          git config fetch.pruneTags true || true
          git tag -l | xargs -r -n 1 git tag -d || true
          retry 5 git -c protocol.version=2 fetch --all --tags --force --prune --prune-tags
          if echo "$TT_METAL_REF" | grep -q '^releases/'; then
            # Treat as branch on origin
            if git rev-parse --verify "$TT_METAL_REF" >/dev/null 2>&1; then
              retry 5 git checkout -f "$TT_METAL_REF"
            else
              retry 5 git checkout -B "$TT_METAL_REF" "origin/$TT_METAL_REF" || retry 5 git checkout -f "origin/$TT_METAL_REF"
            fi
          else
            # Treat as tag or plain ref
            retry 5 git -c advice.detachedHead=false checkout -f "tags/$TT_METAL_REF" || retry 5 git checkout -f "$TT_METAL_REF"
          fi
          # Update nested submodules to the versions recorded by the checked-out ref
          retry 5 git submodule sync --recursive
          retry 5 git submodule update --init --recursive
          # LFS for all nested submodules
          git submodule foreach --recursive 'git lfs fetch --all || true'
          git submodule foreach --recursive 'git lfs pull || true'
          popd

      - name: Install dependencies
        run: |
          apt upgrade -y && apt update -y
          apt install -y cmake python3 python3-venv python3-pip git-lfs ccache
          git config --global --add safe.directory /home/ubuntu/actions-runner/_work/pytorch2.0_ttnn/pytorch2.0_ttnn
          git config --global --add safe.directory /__w/pytorch2.0_ttnn/pytorch2.0_ttnn

          # Remove hugepages setup from install_dependencies.sh
          sed -i '/^configure_hugepages() {/,/^}/c\configure_hugepages() {\n    echo "Skip hugepages installation"\n}' ./torch_ttnn/cpp_extension/third-party/tt-metal/install_dependencies.sh
          ./torch_ttnn/cpp_extension/third-party/tt-metal/install_dependencies.sh

      - name: Install python dependencies
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip config set global.extra-index-url https://download.pytorch.org/whl/cpu
          python3 -m pip install -r requirements-dev.txt
          python3 -m pip install pytest-github-report

          pip install --force-reinstall pip==21.2.4
          python3 -m pip install numpy setuptools wheel
          python3 -m pip install -e . --use-pep517 --no-cache-dir --no-build-isolation

      - name: Build/Fetch C++ Extensions
        run: |
          cd torch_ttnn/cpp_extension
          PYTHON_LIB_SUFFIX=$(python3 -c "import importlib.machinery; print(importlib.machinery.EXTENSION_SUFFIXES[0])")

          CCACHE_DIR=$(ccache --get-config cache_dir)
          mkdir -p $CCACHE_DIR

          # Check if cache exists with required components
          CACHE_FOUND=0
          # if [ -d "$CACHE_DIR/build" ] && [ -f "$CACHE_DIR/ttnn_device_extension${PYTHON_LIB_SUFFIX}" ]; then
          #   CACHE_FOUND=1
          #   echo "Cache found with all required components. Using cached build."

          #   # cpp-extension cache
          #   cp -r $CACHE_DIR/build .
          #   cp -r $CACHE_DIR/ttnn_device_extension${PYTHON_LIB_SUFFIX} .

          #   # tt-metal cache
          #   cp -r $CACHE_DIR/tt-metal/build third-party/tt-metal/
          #   cp -r $CACHE_DIR/tt-metal/.cpmcache third-party/tt-metal/

          #   # ccache
          #   cp -r $CACHE_DIR/ccache/* $CCACHE_DIR
          # else
          #   echo "Cache not found or incomplete. Building C++ extensions"
          # fi
          ./build_cpp_extension.sh
          
          # # Update cache with new build if not was not present before
          # if [ $CACHE_FOUND -eq 0 ]; then
          #   mkdir -p $CACHE_DIR
            
          #   # cpp-extension cache
          #   cp -r build $CACHE_DIR 
          #   cp -r ttnn_device_extension${PYTHON_LIB_SUFFIX} $CACHE_DIR 

          #   # tt-metal cache
          #   mkdir -p $CACHE_DIR/tt-metal
          #   cp -r third-party/tt-metal/build $CACHE_DIR/tt-metal/
          #   cp -r third-party/tt-metal/.cpmcache $CACHE_DIR/tt-metal/

          #   # ccache
          #   cp -r $CCACHE_DIR $CACHE_DIR 
          # fi
          cd ${{ github.workspace }}

      - name: Run C++ Extension Tests
        run: |
          export TT_METAL_HOME=$(realpath ./torch_ttnn/cpp_extension/third-party/tt-metal)
          # Print status, somehere here is is Aborted
          echo "Running C++ extension tests"
          pytest tests/cpp_extension/test_cpp_extension_functionality.py -v

          echo "Running BERT C++ extension tests"
          pytest tests/cpp_extension/test_bert_cpp_extension.py -v

          # echo "Running models C++ extension tests"
          # pytest tests/models/ --native_integration -v

          echo "Running tests passed"

  tests-passed:
    if: ${{ always() }}
    outputs:
      didpass: ${{ steps.check.outputs.didpass }}
    runs-on: ubuntu-latest
    needs: [cpp-extension-tests]
    steps:
      - id: check
        run: |
          cpp_tests_result="${{ needs.cpp-extension-tests.result}}"
          if [[ $cpp_tests_result == "success" || $cpp_tests_result == "skipped" ]]; then
            echo "didpass=0" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "didpass=1" >> $GITHUB_OUTPUT
            exit 1
          fi
